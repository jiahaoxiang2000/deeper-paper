# ML-DSA (FIPS 204)

> the original document is on [here](./pdf/NIST.FIPS.204.pdf).

Module-Lattice-Based Digital Signature Standard

Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of the signatory. In addition, the recipient of signed data can use a digital signature as evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed signatory.

**Keywords:** digital signature, public key cryptography, lattice.

## Introduction

### purpose & scope

The digital signature scheme approved in this standard is the Module-Lattice-Based Digital Signature Algorithm (ML-DSA), which is based on the **Module Learning With Errors problem [4]**.

## Notation

### Rings

Elements of the rings $\mathbb{Z}$, $\mathbb{Z}_q$, $\mathbb{Z}_2$, $R$, and $R_q$ are denoted by italicized lowercase letters (e.g., $w$). Elements of the ring $T_q$ are length-256 arrays of elements of $\mathbb{Z}_q$, and they are denoted by italicized letters with a hat symbol (e.g., $\hat{w}$). The addition and multiplication of elements of $T_q$ are performed entry-wise. Thus, the $i$th entry of the product of two elements $\hat{u}$ and $\hat{v}$ of $T_q$ is $\hat{u}[i] \cdot \hat{v}[i] \in \mathbb{Z}_q$. The multiplication operation in $T_q$ is denoted by the symbol $\circ$ (see Section 2.3).

When a product $a \cdot b$ or a sum $a + b$ is written and either $a$ or $b$ is a congruence class modulo $m$ (i.e., if either $a$ or $b$ is an element of $\mathbb{Z}_m$ or $R_m$), then the product or sum is also understood to be a congruence class modulo $m$ (i.e., an element of $\mathbb{Z}_m$ or $R_m$). Likewise, an element of $R$ or $\mathbb{Z}$ may be “typecast” to an element of $R_m$ or $\mathbb{Z}_m$, respectively, and may be used as the input of a function specified to act on an element of $R_m$ or $\mathbb{Z}_m$, respectively. In both cases, the element itself or its coefficients are mapped from $\mathbb{Z}$ to $\mathbb{Z}_m$ by taking the unique congruence class modulo $m$ that contains the integer.

The coefficients of an element $w$ of $R$ or $R_m$ are denoted by $w_i$ so that $w = w_0 + w_1 X + \dots + w_{255} X^{255}$. If $w$ is in $R$ (respectively, $R_m$) and $t$ is in $\mathbb{Z}$ (respectively, $\mathbb{Z}_d$), then $w(t)$ denotes the polynomial $w = w_0 + w_1 X + \dots + w_{255} X^{255}$ evaluated at $X = t$.

### NTT Representation

The Number Theoretic Transform (NTT) is a specific isomorphism between the rings $R_q$ and $T_q$. Let $\zeta = 1753 \in \mathbb{Z}_q$, which is a 512th root of unity. If $w \in R_q$, then

$$
\mathrm{NTT}(w) = (w(\zeta^0), w(\zeta^1), \ldots, w(\zeta^{255})) \in T_q,
$$

where $\zeta^i = w(\zeta^{2\mathrm{BitRev}_8(i)+1}) \bmod q$. See Section 7.5 for an implementation discussion for NTT and $\mathrm{NTT}^{-1}$.

The motivation for using NTT is that multiplication is considerably faster in the ring $T_q$. Since NTT is an isomorphism, for any $a, b \in R_q$,

$$
\mathrm{NTT}(ab) = \mathrm{NTT}(a) \circ \mathrm{NTT}(b).
$$

If $\mathbf{A}$ is a matrix with entries from $R_q$, then $\mathrm{NTT}(\mathbf{A})$ denotes the matrix computed via the entry-wise application of NTT to $\mathbf{A}$. The symbol $\circ$ is also used to denote the matrix multiplication of matrices with entries in $T_q$. Thus,

$$
\mathrm{NTT}(\mathbf{A}\mathbf{B}) = \mathrm{NTT}(\mathbf{A}) \circ \mathrm{NTT}(\mathbf{B}).
$$

Explicit algorithms for linear algebra over $T_q$ are given in Section 7.6.

## Overview of the ML-DSA

ML-DSA is a digital signature scheme based on CRYSTALS-DILITHIUM [6]. It consists of three main algorithms: ML-DSA.KeyGen (Algorithm 1), ML-DSA.Sign (Algorithm 2), and ML-DSA.Verify (Algorithm 3). T

### Computational Assumptions

Security for lattice-based digital signature schemes is typically related to the Learning With Errors (LWE) problem and the short integer solution (SIS) problem.

#### Learning With Errors (LWE)

The LWE problem is to recover a vector $\mathbf{s} \in \mathbb{Z}_q^n$ given a set of random "noisy" linear equations satisfied by $\mathbf{s}$. Specifically, the LWE problem is to solve a system of equations of the form $\mathbf{A}\mathbf{s} + \mathbf{e} = \mathbf{b}$, where $\mathbf{A}$ and $\mathbf{b}$ are given and $\mathbf{e}$ is not given but known to be small.

#### Short Integer Solution (SIS)

The SIS problem is to find a non-zero solution $\mathbf{t} \in \mathbb{Z}_q^n$ for a given linear system over $\mathbb{Z}_q$ of the form $\mathbf{A}\mathbf{t} = \mathbf{0}$ such that $\|\mathbf{t}\|_\infty$ is small. For appropriate choices of parameters, these problems are intractable for the best known techniques, including Gaussian elimination.

#### Module Variants

When the module $\mathbb{Z}_q^n$ in LWE and SIS is replaced by a module over a ring larger than $\mathbb{Z}_q$ (e.g., $R_q$), the resulting problems are called Module Learning With Errors (MLWE) and Module Short Integer Solution (MSIS).

The security of ML-DSA is based on the MLWE problem over $R_q$ and a nonstandard variant of MSIS called SelfTargetMSIS.

### ML-DSA Construction

ML-DSA is a Schnorr-like signature with several optimizations. The Schnorr signature scheme applies the Fiat-Shamir heuristic to an interactive protocol between a verifier who knows $g$ (the generator of a group in which discrete logs are believed to be difficult) and the value $y = g^x$ and a prover who knows $g$ and $x$. The interactive protocol, where the prover demonstrates knowledge of $x$ to the verifier, consists of three steps:

1. **Commitment**: The prover generates a random positive integer $r$ that is less than the order of $g$ and commits to its value by sending $g^r$ to the verifier.
2. **Challenge**: The verifier sends a random positive integer $c$ that is less than the order of $g$ to the prover.
3. **Response**: The prover returns $s = r - cx$ reduced modulo the order of $g$, and the verifier checks whether $g^s \cdot y^c = g^r$.

This protocol is made noninteractive and turned into a signature scheme by replacing the verifier's random choice of $c$ in step 2 with a deterministic process that pseudorandomly derives $c$ from a hash of the commitment $g^r$ concatenated with the message to be signed. For this signature scheme, $y$ is the public key, and $x$ is the private key.

#### Lattice-Based Analog

The basic idea of ML-DSA and similar lattice signature schemes is to build a signature scheme from an analogous interactive protocol, where a prover who knows matrices $\mathbf{A} \in \mathbb{Z}_q^{K \times L}$, $\mathbf{S}_1 \in \mathbb{Z}_q^{L \times n}$, and $\mathbf{S}_2 \in \mathbb{Z}_q^{K \times n}$ with small coefficients (for $\mathbf{S}_1$ and $\mathbf{S}_2$) demonstrates knowledge of these matrices to a verifier who knows $\mathbf{A}$ and $\mathbf{T} \in \mathbb{Z}_q^{K \times n} = \mathbf{A}\mathbf{S}_1 + \mathbf{S}_2$. Such an interactive protocol would proceed as follows:

1. **Commitment**: The prover generates $\mathbf{y} \in \mathbb{Z}_q^L$ with small coefficients and commits to its value by sending $\mathbf{w}_{\text{Approx}} = \mathbf{A}\mathbf{y} + \mathbf{y}_2$ to the verifier, where $\mathbf{y}_2 \in \mathbb{Z}_q^K$ is a vector with small coefficients.
2. **Challenge**: The verifier sends a vector $\mathbf{c} \in \mathbb{Z}_q^n$ with small coefficients to the prover.
3. **Response**: The prover returns $\mathbf{z} = \mathbf{y} + \mathbf{S}_1\mathbf{c}$, and the verifier checks that $\mathbf{z}$ has small coefficients and that $\mathbf{A}\mathbf{z} - \mathbf{T}\mathbf{c} \approx \mathbf{w}_{\text{Approx}}$.

#### Fiat-Shamir With Aborts

As written, the above protocol has a security flaw: the response $\mathbf{z}$ will be biased in a direction related to the private value $\mathbf{S}_1$. Likewise $\mathbf{r} = \mathbf{w}_{\text{Approx}} - \mathbf{A}\mathbf{z} + \mathbf{T}\mathbf{c} = \mathbf{y}_2 + \mathbf{S}_2\mathbf{c}$ is biased in a direction related to the private value $\mathbf{S}_2$.

However, this flaw can be corrected when converting the interactive protocol into a signature scheme. As with Schnorr signatures, the signer derives the challenge by a pseudorandom process from a hash of the commitment concatenated with the message. To correct the bias, the signer applies rejection sampling to $\mathbf{z}$; if coefficients of $\mathbf{z}$ fall outside of a specified range, the signing process is aborted, and the signer starts over from a new value of $\mathbf{y}$. Likewise, similar rejection sampling must also be applied to $\mathbf{r}$.

In the simplified Fiat-Shamir With Aborts signature, the public key is $(\mathbf{A}, \mathbf{T})$, and the private key is $(\mathbf{S}_1, \mathbf{S}_2)$.

## Core ML-DSA Algorithms

### External Functions

ML-DSA provides "external" and "internal" algorithm components to simplify APIs and testing. External components handle randomness generation and validation checks, while internal components are deterministic.

#### Algorithm 1: ML-DSA.KeyGen()

**Purpose**: Generates a public-private key pair

**Output**: 
- Public key $pk \in \mathbb{B}^{32+32k(\text{bitlen}(q-1)-d)}$ 
- Private key $sk \in \mathbb{B}^{32+32+64+32\cdot((\ell+k)\cdot\text{bitlen}(2\eta)+dk)}$

**Steps**:
1. Generate 256-bit random seed $\xi \leftarrow \mathbb{B}^{32}$
2. If $\xi = \text{NULL}$ then return $\perp$ (error)
3. Return ML-DSA.KeyGen_internal($\xi$)

#### Algorithm 2: ML-DSA.Sign(sk, M, ctx)

**Purpose**: Generates an ML-DSA signature

**Input**: 
- Private key $sk$
- Message $M \in \{0,1\}^*$
- Context string $ctx$ (≤255 bytes)

**Output**: Signature $\sigma \in \mathbb{B}^{\lambda/4+\ell\cdot32\cdot(1+\text{bitlen}(\gamma_1-1))+\omega+k}$

**Steps**:
1. If $|ctx| > 255$ then return $\perp$
2. Generate random seed $rnd \leftarrow \mathbb{B}^{32}$ (or $rnd \leftarrow \{0\}^{32}$ for deterministic variant)
3. If $rnd = \text{NULL}$ then return $\perp$
4. Encode message: $M' \leftarrow \text{BytesToBits}(\text{IntegerToBytes}(0,1) \| \text{IntegerToBytes}(|ctx|,1) \| ctx) \| M$
5. Return ML-DSA.Sign_internal($sk, M', rnd$)

#### Algorithm 3: ML-DSA.Verify(pk, M, σ, ctx)

**Purpose**: Verifies a signature $\sigma$ for a message $M$

**Input**:
- Public key $pk$
- Message $M \in \{0,1\}^*$
- Signature $\sigma$
- Context string $ctx$ (≤255 bytes)

**Output**: Boolean (true if valid, false if invalid)

**Steps**:
1. If $|ctx| > 255$ then return $\perp$
2. Encode message: $M' \leftarrow \text{BytesToBits}(\text{IntegerToBytes}(0,1) \| \text{IntegerToBytes}(|ctx|,1) \| ctx) \| M$
3. Return ML-DSA.Verify_internal($pk, M', \sigma$)

### Pre-Hash ML-DSA (HashML-DSA)

HashML-DSA is a performance-optimized variant of ML-DSA designed for specific deployment scenarios involving large messages or hardware constraints.

#### Key Differences from Standard ML-DSA

**Standard ML-DSA** (Pure ML-DSA):
- Signs the entire message directly using SHAKE256
- Provides stronger security guarantees 
- Preferred for most applications
- Message size directly affects signing performance

**HashML-DSA** (Pre-Hash ML-DSA):
- Pre-hashes the message using SHA-256, SHA-512, or SHAKE128
- Signs the hash digest (32-64 bytes) instead of the full message
- Includes domain separation and hash function identification
- Uses domain separator value `1` vs `0` for pure ML-DSA

#### When to Use HashML-DSA

**Use HashML-DSA when**:
1. **Large Message Performance**: Signing very large messages (>1MB) where hashing the entire message with SHAKE256 becomes a bottleneck
2. **Hardware Constraints**: Platform has hardware acceleration for SHA-256/SHA-512 but not SHAKE256
3. **Streaming/Incremental Processing**: Need to process messages in chunks without loading entire message into memory
4. **Legacy Hash Integration**: Must integrate with existing systems that already compute SHA-256/SHA-512 hashes
5. **Bandwidth-Limited Environments**: Pre-computed hashes can be transmitted separately from signing operation

**Use Standard ML-DSA when**:
1. **Maximum Security**: Want strongest possible security guarantees
2. **Small to Medium Messages**: Message size doesn't create performance issues
3. **SHAKE256 Available**: Platform has efficient SHAKE256 implementation
4. **Simplicity**: Prefer simpler protocol without hash function coordination

#### Security Considerations

**HashML-DSA Security Requirements**:
- Hash function must provide at least λ bits of classical security strength against both collision and second preimage attacks
- For collision resistance: digest must be at least 2λ bits (e.g., 512 bits for λ=256)
- Hash function must be FIPS-approved (FIPS 180 or FIPS 202)

**Domain Separation**:
- Uses different domain separators to prevent cross-protocol attacks
- Standard ML-DSA: domain separator = 0
- HashML-DSA: domain separator = 1
- Includes hash function OID for unambiguous identification

#### Implementation Notes

1. **Key Pair Compatibility**: Same key pair can be used for both ML-DSA and HashML-DSA, but it's recommended to use each key pair for only one variant

2. **Signature Identification**: The signature identifier (OID) must clearly indicate:
   - Whether it's ML-DSA or HashML-DSA
   - Which hash function was used (for HashML-DSA)
   - Context string usage

3. **FIPS 140 Requirements**: 
   - Pre-hashing must occur within a FIPS 140-validated cryptographic module
   - Can be different module than the one performing ML-DSA.Sign_internal
   - Random value generation must happen in the signing module

4. **Context String Handling**: Both variants support context strings (≤255 bytes) for additional domain separation

HashML-DSA provides a practical solution for performance-critical applications while maintaining post-quantum security, but standard ML-DSA should be preferred when performance isn't a limiting factor.

#### Algorithm 4: HashML-DSA.Sign(sk, M, ctx, PH)

**Purpose**: Generate a "pre-hash" ML-DSA signature

**Input**:
- Private key $sk$
- Message $M \in \{0,1\}^*$
- Context string $ctx$ (≤255 bytes)
- Pre-hash function PH

**Steps**:
1. If $|ctx| > 255$ then return $\perp$
2. Generate $rnd \leftarrow \mathbb{B}^{32}$ (or $\{0\}^{32}$ for deterministic)
3. Switch on PH:
   - SHA-256: Set OID and compute $PH_M \leftarrow \text{SHA256}(M)$
   - SHA-512: Set OID and compute $PH_M \leftarrow \text{SHA512}(M)$
   - SHAKE128: Set OID and compute $PH_M \leftarrow \text{SHAKE128}(M, 256)$
4. Construct $M' \leftarrow \text{BytesToBits}(\text{IntegerToBytes}(1,1) \| \text{IntegerToBytes}(|ctx|,1) \| ctx \| \text{OID} \| PH_M)$
5. Return ML-DSA.Sign_internal($sk, M', rnd$)

#### Algorithm 5: HashML-DSA.Verify(pk, M, σ, ctx, PH)

**Purpose**: Verifies a pre-hash HashML-DSA signature

**Input**: Public key $pk$, message $M$, signature $\sigma$, context $ctx$, pre-hash function PH

**Steps**:
1. If $|ctx| > 255$ then return false
2. Apply same pre-hash processing as signing
3. Return ML-DSA.Verify_internal($pk, M', \sigma$)

### Internal Functions

#### Algorithm 6: ML-DSA.KeyGen_internal(ξ)

**Purpose**: Internal key generation from seed

**Input**: Seed $\xi \in \mathbb{B}^{32}$

**Steps**:
1. Expand seed: $(\rho, \rho', K) \leftarrow H(\xi \| \text{IntegerToBytes}(k,1) \| \text{IntegerToBytes}(\ell,1), 128)$
2. Generate matrix: $\hat{\mathbf{A}} \leftarrow \text{ExpandA}(\rho)$ (in NTT form)
3. Generate secret vectors: $(\mathbf{s}_1, \mathbf{s}_2) \leftarrow \text{ExpandS}(\rho')$
4. Compute public value: $\mathbf{t} \leftarrow \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \text{NTT}(\mathbf{s}_1)) + \mathbf{s}_2$
5. Compress: $(\mathbf{t}_1, \mathbf{t}_0) \leftarrow \text{Power2Round}(\mathbf{t})$
6. Encode keys:
   - $pk \leftarrow \text{pkEncode}(\rho, \mathbf{t}_1)$
   - $tr \leftarrow H(pk, 64)$
   - $sk \leftarrow \text{skEncode}(\rho, K, tr, \mathbf{s}_1, \mathbf{s}_2, \mathbf{t}_0)$
7. Return $(pk, sk)$

#### Algorithm 7: ML-DSA.Sign_internal(sk, M', rnd)

**Purpose**: Internal signature generation

**Input**: Private key $sk$, formatted message $M'$, randomness $rnd$

**Steps**:
1. Extract from private key: $(\rho, K, tr, \mathbf{s}_1, \mathbf{s}_2, \mathbf{t}_0) \leftarrow \text{skDecode}(sk)$
2. Convert to NTT form: $\hat{\mathbf{s}}_1, \hat{\mathbf{s}}_2, \hat{\mathbf{t}}_0 \leftarrow \text{NTT}(\mathbf{s}_1), \text{NTT}(\mathbf{s}_2), \text{NTT}(\mathbf{t}_0)$
3. Generate matrix: $\hat{\mathbf{A}} \leftarrow \text{ExpandA}(\rho)$
4. Compute message representative: $\mu \leftarrow H(\text{BytesToBits}(tr) \| M', 64)$
5. Compute private random seed: $\rho'' \leftarrow H(K \| rnd \| \mu, 64)$
6. Initialize counter: $\kappa \leftarrow 0$

**Rejection Sampling Loop**:
7. While $(\mathbf{z}, \mathbf{h}) = \perp$:
   - Generate mask: $\mathbf{y} \leftarrow \text{ExpandMask}(\rho'', \kappa)$
   - Compute commitment: $\mathbf{w} \leftarrow \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \text{NTT}(\mathbf{y}))$
   - Get high bits: $\mathbf{w}_1 \leftarrow \text{HighBits}(\mathbf{w})$
   - Hash commitment: $\tilde{c} \leftarrow H(\mu \| \text{w1Encode}(\mathbf{w}_1), \lambda/4)$
   - Sample challenge: $c \leftarrow \text{SampleInBall}(\tilde{c})$
   - Convert to NTT: $\hat{c} \leftarrow \text{NTT}(c)$
   - Compute responses: 
     - $\langle\langle c\mathbf{s}_1 \rangle\rangle \leftarrow \text{NTT}^{-1}(\hat{c} \circ \hat{\mathbf{s}}_1)$
     - $\langle\langle c\mathbf{s}_2 \rangle\rangle \leftarrow \text{NTT}^{-1}(\hat{c} \circ \hat{\mathbf{s}}_2)$
     - $\mathbf{z} \leftarrow \mathbf{y} + \langle\langle c\mathbf{s}_1 \rangle\rangle$
   - Compute low bits: $\mathbf{r}_0 \leftarrow \text{LowBits}(\mathbf{w} - \langle\langle c\mathbf{s}_2 \rangle\rangle)$
   - **Validity checks**:
     - If $\|\mathbf{z}\|_\infty \geq \gamma_1 - \beta$ or $\|\mathbf{r}_0\|_\infty \geq \gamma_2 - \beta$ then $(\mathbf{z}, \mathbf{h}) \leftarrow \perp$
     - Else:
       - $\langle\langle c\mathbf{t}_0 \rangle\rangle \leftarrow \text{NTT}^{-1}(\hat{c} \circ \hat{\mathbf{t}}_0)$
       - $\mathbf{h} \leftarrow \text{MakeHint}(-\langle\langle c\mathbf{t}_0 \rangle\rangle, \mathbf{w} - \langle\langle c\mathbf{s}_2 \rangle\rangle + \langle\langle c\mathbf{t}_0 \rangle\rangle)$
       - If $\|\langle\langle c\mathbf{t}_0 \rangle\rangle\|_\infty \geq \gamma_2$ or number of 1's in $\mathbf{h} > \omega$ then $(\mathbf{z}, \mathbf{h}) \leftarrow \perp$
   - Increment counter: $\kappa \leftarrow \kappa + \ell$

8. Encode signature: $\sigma \leftarrow \text{sigEncode}(\tilde{c}, \mathbf{z} \bmod \pm q, \mathbf{h})$
9. Return $\sigma$

#### Algorithm 8: ML-DSA.Verify_internal(pk, M', σ)

**Purpose**: Internal signature verification

**Input**: Public key $pk$, formatted message $M'$, signature $\sigma$

**Steps**:
1. Extract from public key: $(\rho, \mathbf{t}_1) \leftarrow \text{pkDecode}(pk)$
2. Extract from signature: $(\tilde{c}, \mathbf{z}, \mathbf{h}) \leftarrow \text{sigDecode}(\sigma)$
3. If $\mathbf{h} = \perp$ then return false (malformed hint)
4. Generate matrix: $\hat{\mathbf{A}} \leftarrow \text{ExpandA}(\rho)$
5. Compute public key hash: $tr \leftarrow H(pk, 64)$
6. Compute message representative: $\mu \leftarrow H(\text{BytesToBits}(tr) \| M', 64)$
7. Sample challenge: $c \leftarrow \text{SampleInBall}(\tilde{c})$
8. Reconstruct commitment: $\mathbf{w}'_{\text{Approx}} \leftarrow \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \text{NTT}(\mathbf{z}) - \text{NTT}(c) \circ \text{NTT}(\mathbf{t}_1 \cdot 2^d))$
9. Use hint: $\mathbf{w}'_1 \leftarrow \text{UseHint}(\mathbf{h}, \mathbf{w}'_{\text{Approx}})$
10. Hash reconstructed commitment: $\tilde{c}' \leftarrow H(\mu \| \text{w1Encode}(\mathbf{w}'_1), \lambda/4)$
11. Return $[\|\mathbf{z}\|_\infty < \gamma_1 - \beta]$ AND $[\tilde{c} = \tilde{c}']$

## Auxiliary Functions

### Data Type Conversions

#### Integer/Bit/Byte Conversions

- **IntegerToBits(x, α)**: Converts integer to α-bit string (little-endian)
- **BitsToInteger(y, α)**: Converts α-bit string to integer  
- **IntegerToBytes(x, α)**: Converts integer to α-byte string (little-endian)
- **BitsToBytes(y)**: Converts bit string to byte string
- **BytesToBits(z)**: Converts byte string to bit string

#### Coefficient Generation

- **CoeffFromThreeBytes(b₀, b₁, b₂)**: Generates element of {0,1,...,q-1} ∪ {⊥} using rejection sampling
- **CoeffFromHalfByte(b)**: Generates element of {-η,...,η} ∪ {⊥} for η ∈ {2,4}

#### Polynomial Packing

- **SimpleBitPack(w, b)**: Encodes polynomial w with coefficients in [0,b] to byte string
- **BitPack(w, a, b)**: Encodes polynomial w with coefficients in [-a,b] to byte string  
- **SimpleBitUnpack(v, b)**: Reverses SimpleBitPack
- **BitUnpack(v, a, b)**: Reverses BitPack

#### Hint Encoding

- **HintBitPack(h)**: Encodes sparse binary polynomial vector h to byte string
- **HintBitUnpack(y)**: Reverses HintBitPack

### Key and Signature Encodings

- **pkEncode(ρ, t₁)**: Encodes public key to byte string
- **pkDecode(pk)**: Decodes public key from byte string
- **skEncode(ρ, K, tr, s₁, s₂, t₀)**: Encodes private key to byte string
- **skDecode(sk)**: Decodes private key from byte string
- **sigEncode(c̃, z, h)**: Encodes signature to byte string
- **sigDecode(σ)**: Decodes signature from byte string
- **w1Encode(w₁)**: Encodes polynomial vector w₁ for hashing

### Pseudorandom Sampling

#### Core Sampling Functions

- **SampleInBall(ρ)**: Samples polynomial c ∈ R with coefficients from {-1,0,1} and Hamming weight τ using Fisher-Yates shuffle
- **RejNTTPoly(ρ)**: Samples polynomial in T_q using rejection sampling
- **RejBoundedPoly(ρ)**: Samples polynomial in R with coefficients in [-η,η]

#### Expansion Functions

- **ExpandA(ρ)**: Samples k×ℓ matrix Â of elements in T_q
- **ExpandS(ρ)**: Samples vectors s₁ ∈ R^ℓ and s₂ ∈ R^k with coefficients in [-η,η]
- **ExpandMask(ρ, μ)**: Samples vector y ∈ R^ℓ with coefficients in [-γ₁+1, γ₁]

### High/Low Bits and Hints

These functions support key compression optimization and hint generation:

#### Decomposition Functions

- **Power2Round(r)**: Decomposes r into (r₁, r₀) such that r ≡ r₁2^d + r₀ (mod q)
- **Decompose(r)**: Decomposes r into (r₁, r₀) such that r ≡ r₁(2γ₂) + r₀ (mod q) with special handling for wrap-around
- **HighBits(r)**: Returns r₁ from Decompose(r)
- **LowBits(r)**: Returns r₀ from Decompose(r)

#### Hint Functions

- **MakeHint(z, r)**: Computes Boolean hint indicating whether adding z to r alters the high bits
- **UseHint(h, r)**: Returns high bits of r adjusted according to hint h

### Number Theoretic Transform (NTT)

#### Core NTT Operations

- **NTT(w)**: Computes forward NTT of polynomial w ∈ R_q to ŵ ∈ T_q
- **NTT⁻¹(ŵ)**: Computes inverse NTT from ŵ ∈ T_q back to w ∈ R_q  
- **BitRev8(m)**: Reverses bit order in 8-bit integer

#### NTT Arithmetic

- **AddNTT(â, b̂)**: Addition of two elements in T_q (componentwise)
- **MultiplyNTT(â, b̂)**: Multiplication of two elements in T_q (componentwise)
- **AddVectorNTT(v̂, ŵ)**: Vector addition over T_q
- **ScalarVectorNTT(ĉ, v̂)**: Scalar-vector multiplication over T_q
- **MatrixVectorNTT(M̂, v̂)**: Matrix-vector multiplication over T_q

The NTT uses ζ = 1753 ∈ Z_q as a 512th root of unity, with precomputed zetas table for efficiency.
