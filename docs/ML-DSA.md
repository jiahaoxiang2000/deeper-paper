# ML-DSA (FIPS 204)

> the original document is on [here](./pdf/NIST.FIPS.204.pdf).

Module-Lattice-Based Digital Signature Standard

Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of the signatory. In addition, the recipient of signed data can use a digital signature as evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed signatory.

**Keywords:** digital signature, public key cryptography, lattice.

## Introduction

### purpose & scope

The digital signature scheme approved in this standard is the Module-Lattice-Based Digital Signature Algorithm (ML-DSA), which is based on the **Module Learning With Errors problem [4]**.

## Notation

### Rings

Elements of the rings $\mathbb{Z}$, $\mathbb{Z}_q$, $\mathbb{Z}_2$, $R$, and $R_q$ are denoted by italicized lowercase letters (e.g., $w$). Elements of the ring $T_q$ are length-256 arrays of elements of $\mathbb{Z}_q$, and they are denoted by italicized letters with a hat symbol (e.g., $\hat{w}$). The addition and multiplication of elements of $T_q$ are performed entry-wise. Thus, the $i$th entry of the product of two elements $\hat{u}$ and $\hat{v}$ of $T_q$ is $\hat{u}[i] \cdot \hat{v}[i] \in \mathbb{Z}_q$. The multiplication operation in $T_q$ is denoted by the symbol $\circ$ (see Section 2.3).

When a product $a \cdot b$ or a sum $a + b$ is written and either $a$ or $b$ is a congruence class modulo $m$ (i.e., if either $a$ or $b$ is an element of $\mathbb{Z}_m$ or $R_m$), then the product or sum is also understood to be a congruence class modulo $m$ (i.e., an element of $\mathbb{Z}_m$ or $R_m$). Likewise, an element of $R$ or $\mathbb{Z}$ may be “typecast” to an element of $R_m$ or $\mathbb{Z}_m$, respectively, and may be used as the input of a function specified to act on an element of $R_m$ or $\mathbb{Z}_m$, respectively. In both cases, the element itself or its coefficients are mapped from $\mathbb{Z}$ to $\mathbb{Z}_m$ by taking the unique congruence class modulo $m$ that contains the integer.

The coefficients of an element $w$ of $R$ or $R_m$ are denoted by $w_i$ so that $w = w_0 + w_1 X + \dots + w_{255} X^{255}$. If $w$ is in $R$ (respectively, $R_m$) and $t$ is in $\mathbb{Z}$ (respectively, $\mathbb{Z}_d$), then $w(t)$ denotes the polynomial $w = w_0 + w_1 X + \dots + w_{255} X^{255}$ evaluated at $X = t$.

### NTT Representation

The Number Theoretic Transform (NTT) is a specific isomorphism between the rings $R_q$ and $T_q$. Let $\zeta = 1753 \in \mathbb{Z}_q$, which is a 512th root of unity. If $w \in R_q$, then

$$
\mathrm{NTT}(w) = (w(\zeta^0), w(\zeta^1), \ldots, w(\zeta^{255})) \in T_q,
$$

where $\zeta^i = w(\zeta^{2\mathrm{BitRev}_8(i)+1}) \bmod q$. See Section 7.5 for an implementation discussion for NTT and $\mathrm{NTT}^{-1}$.

The motivation for using NTT is that multiplication is considerably faster in the ring $T_q$. Since NTT is an isomorphism, for any $a, b \in R_q$,

$$
\mathrm{NTT}(ab) = \mathrm{NTT}(a) \circ \mathrm{NTT}(b).
$$

If $\mathbf{A}$ is a matrix with entries from $R_q$, then $\mathrm{NTT}(\mathbf{A})$ denotes the matrix computed via the entry-wise application of NTT to $\mathbf{A}$. The symbol $\circ$ is also used to denote the matrix multiplication of matrices with entries in $T_q$. Thus,

$$
\mathrm{NTT}(\mathbf{A}\mathbf{B}) = \mathrm{NTT}(\mathbf{A}) \circ \mathrm{NTT}(\mathbf{B}).
$$

Explicit algorithms for linear algebra over $T_q$ are given in Section 7.6.

## Overview of the ML-DSA

ML-DSA is a digital signature scheme based on CRYSTALS-DILITHIUM [6]. It consists of three main algorithms: ML-DSA.KeyGen (Algorithm 1), ML-DSA.Sign (Algorithm 2), and ML-DSA.Verify (Algorithm 3). T

### Computational Assumptions

Security for lattice-based digital signature schemes is typically related to the Learning With Errors (LWE) problem and the short integer solution (SIS) problem.

#### Learning With Errors (LWE)

The LWE problem is to recover a vector $\mathbf{s} \in \mathbb{Z}_q^n$ given a set of random "noisy" linear equations satisfied by $\mathbf{s}$. Specifically, the LWE problem is to solve a system of equations of the form $\mathbf{A}\mathbf{s} + \mathbf{e} = \mathbf{b}$, where $\mathbf{A}$ and $\mathbf{b}$ are given and $\mathbf{e}$ is not given but known to be small.

#### Short Integer Solution (SIS)

The SIS problem is to find a non-zero solution $\mathbf{t} \in \mathbb{Z}_q^n$ for a given linear system over $\mathbb{Z}_q$ of the form $\mathbf{A}\mathbf{t} = \mathbf{0}$ such that $\|\mathbf{t}\|_\infty$ is small. For appropriate choices of parameters, these problems are intractable for the best known techniques, including Gaussian elimination.

#### Module Variants

When the module $\mathbb{Z}_q^n$ in LWE and SIS is replaced by a module over a ring larger than $\mathbb{Z}_q$ (e.g., $R_q$), the resulting problems are called Module Learning With Errors (MLWE) and Module Short Integer Solution (MSIS).

The security of ML-DSA is based on the MLWE problem over $R_q$ and a nonstandard variant of MSIS called SelfTargetMSIS.

### ML-DSA Construction

ML-DSA is a Schnorr-like signature with several optimizations. The Schnorr signature scheme applies the Fiat-Shamir heuristic to an interactive protocol between a verifier who knows $g$ (the generator of a group in which discrete logs are believed to be difficult) and the value $y = g^x$ and a prover who knows $g$ and $x$. The interactive protocol, where the prover demonstrates knowledge of $x$ to the verifier, consists of three steps:

1. **Commitment**: The prover generates a random positive integer $r$ that is less than the order of $g$ and commits to its value by sending $g^r$ to the verifier.
2. **Challenge**: The verifier sends a random positive integer $c$ that is less than the order of $g$ to the prover.
3. **Response**: The prover returns $s = r - cx$ reduced modulo the order of $g$, and the verifier checks whether $g^s \cdot y^c = g^r$.

This protocol is made noninteractive and turned into a signature scheme by replacing the verifier's random choice of $c$ in step 2 with a deterministic process that pseudorandomly derives $c$ from a hash of the commitment $g^r$ concatenated with the message to be signed. For this signature scheme, $y$ is the public key, and $x$ is the private key.

#### Lattice-Based Analog

The basic idea of ML-DSA and similar lattice signature schemes is to build a signature scheme from an analogous interactive protocol, where a prover who knows matrices $\mathbf{A} \in \mathbb{Z}_q^{K \times L}$, $\mathbf{S}_1 \in \mathbb{Z}_q^{L \times n}$, and $\mathbf{S}_2 \in \mathbb{Z}_q^{K \times n}$ with small coefficients (for $\mathbf{S}_1$ and $\mathbf{S}_2$) demonstrates knowledge of these matrices to a verifier who knows $\mathbf{A}$ and $\mathbf{T} \in \mathbb{Z}_q^{K \times n} = \mathbf{A}\mathbf{S}_1 + \mathbf{S}_2$. Such an interactive protocol would proceed as follows:

1. **Commitment**: The prover generates $\mathbf{y} \in \mathbb{Z}_q^L$ with small coefficients and commits to its value by sending $\mathbf{w}_{\text{Approx}} = \mathbf{A}\mathbf{y} + \mathbf{y}_2$ to the verifier, where $\mathbf{y}_2 \in \mathbb{Z}_q^K$ is a vector with small coefficients.
2. **Challenge**: The verifier sends a vector $\mathbf{c} \in \mathbb{Z}_q^n$ with small coefficients to the prover.
3. **Response**: The prover returns $\mathbf{z} = \mathbf{y} + \mathbf{S}_1\mathbf{c}$, and the verifier checks that $\mathbf{z}$ has small coefficients and that $\mathbf{A}\mathbf{z} - \mathbf{T}\mathbf{c} \approx \mathbf{w}_{\text{Approx}}$.

#### Fiat-Shamir With Aborts

As written, the above protocol has a security flaw: the response $\mathbf{z}$ will be biased in a direction related to the private value $\mathbf{S}_1$. Likewise $\mathbf{r} = \mathbf{w}_{\text{Approx}} - \mathbf{A}\mathbf{z} + \mathbf{T}\mathbf{c} = \mathbf{y}_2 + \mathbf{S}_2\mathbf{c}$ is biased in a direction related to the private value $\mathbf{S}_2$.

However, this flaw can be corrected when converting the interactive protocol into a signature scheme. As with Schnorr signatures, the signer derives the challenge by a pseudorandom process from a hash of the commitment concatenated with the message. To correct the bias, the signer applies rejection sampling to $\mathbf{z}$; if coefficients of $\mathbf{z}$ fall outside of a specified range, the signing process is aborted, and the signer starts over from a new value of $\mathbf{y}$. Likewise, similar rejection sampling must also be applied to $\mathbf{r}$.

In the simplified Fiat-Shamir With Aborts signature, the public key is $(\mathbf{A}, \mathbf{T})$, and the private key is $(\mathbf{S}_1, \mathbf{S}_2)$.

#### ML-DSA Optimizations

In the ML-DSA standard, a number of tweaks and modifications are added to this basic framework for security or efficiency reasons:

- **Module Structure**: To reduce key and signature size and to use fast NTT-based polynomial multiplication, ML-DSA uses module-structured matrices. It replaces dimension-$n \times n$ blocks of matrices and dimension-$n$ blocks of vectors with polynomials in the ring $R_q$. Thus, ML-DSA has $\mathbf{A} \in R_q^{k \times \ell}$, $\mathbf{t} \in R_q^k$, $\mathbf{s}_1 \in R_q^\ell$, $\mathbf{s}_2 \in R_q^k$, $\mathbf{y} \in R_q^\ell$, $c \in R_q$, where $\ell = L/n$ and $k = K/n$.

- **Compressed Public Key**: To further reduce the size of the public key, the matrix $\mathbf{A}$ is pseudorandomly derived from a 256-bit public seed $\rho$, which is included in the ML-DSA public key in place of $\mathbf{A}$.

- **Further Compression**: For a still further reduction in public key size, the ML-DSA public key substitutes a compressed value $\mathbf{t}_1$ for $\mathbf{t}$, which drops the $d$ low-order bits of each coefficient.

- **BUFF Properties**: To obtain beyond unforgeability (BUFF) properties, ML-DSA does not directly sign the message $M$ but rather signs a message representative $\mu$ that is obtained by hashing the concatenation of a hash of the public key and $M$.
